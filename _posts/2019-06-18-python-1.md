---
 title: (Python 입문기) 파이썬 특이점 정리 1 (자료형, 제어문)
 layout: post
 date: '2019-06-18 03:00:00'
 author: 줌코딩
 tags: python
 cover: "/assets/instacode.png"
 categories: python
---
 
## 자료형
 
### 숫자형

- x ** y : x의 y제곱을 의미
- x // y : x를 y로 나눈 몫을 반환

### 문자형

    >>> a = "Life is too short, You need Python"

- a[-2] = 'o' : 뒤로 가는 인덱싱도 가능하다
- a[0:3] = 'Lif' : a의 0번째부터 2번까지의 단어
- a[19:] = 'You need Python' : 끝번호 생략시 시작번호부터 끝까지
- a[:17] = 'Life is too short' : 시작번호 생략시 0번부터 끝번호까지

**문자열 포매팅**

    >>> number = 10
    >>> day = "three"
    >>> "I ate %d apples. so I was sick for %s days." % (number, day)
    
위와 같이 값을 포맷코드를 이용해서 입력을 넣어줄수있다.

또다른 방법으로는 format 함수를 이용하는 방법이 있다.

    >>> "I ate {number} apples. so I was sick for {day} days.".format(number=10, day=3)
    'I ate 10 apples. so I was sick for 3 days.'
    
    >>> number = 10
    >>> day = "three"
    >>> "I ate {0} apples. so I was sick for {1} days.".format(number, day)
    'I ate 10 apples. so I was sick for three days.'

**문자 개수 세기**

    >>> a = "hobby"
    >>> a.count('b')
    2

**위치 알려주기**

    >>> a = "Python is the best choice"
    >>> a.find('b')
    14
    >>> a.find('k')
    -1
    
**문자열 삽입**

    >>> ",".join('abcd')
    'a,b,c,d'
    
**문자열 바꾸기**

    >>> a = "Life is too short"
    >>> a.replace("Life", "Your leg")
    'Your leg is too short'
    
**문자열 나누기**

    >>> a = "Life is too short"
    >>> a.split()
    ['Life', 'is', 'too', 'short']
    >>> a = "a:b:c:d"
    >>> a.split(':')
    ['a', 'b', 'c', 'd']
    
아무것도 넣어주지 않으면 그냥 공백(스페이스, 탭, 엔터 등)을 기준으로 나눈다.


### 리스트

**리스트 요소 삭제하기**

    >>> a = [1, 2, 3]
    >>> del a[1]
    >>> a
    [1, 3]
    
리스트는 어레이와 다르게 중간에 요소를 삭제도 할 수 있다.

del은 모든 자료형을 지울수 있다고 한다.

**리스트 요소 추가(append)**

    >>> a = [1, 2, 3]
    >>> a.append(4)
    >>> a
    [1, 2, 3, 4]

**리스트 정렬**

    >>> a = [1, 4, 3, 2]
    >>> a.sort()
    >>> a
    [1, 2, 3, 4]
    
**리스트 뒤집기**

    >>> a = ['a', 'c', 'b']
    >>> a.reverse()
    >>> a
    ['b', 'c', 'a']
    
**리스트 위치 반환**

    >>> a = [1,2,3]
    >>> a.index(3)
    2
    >>> a.index(1)
    0

**리스트 삽입**

    >>> a = [1, 2, 3]
    >>> a.insert(0, 4)
    >>> a
    [4, 1, 2, 3]

위와 같이 리스트 0번째 위치에 4를 추가한다.

**리스트 삭제(값으로)**

    >>> a = [1, 2, 3, 1, 2, 3]
    >>> a.remove(3)
    >>> a
    [1, 2, 1, 2, 3]

리스트에서 해당 값을 가지고 있는 첫 원소를 삭제한다.

**리스트 요소 끄집어내기 (인덱스로)**

    >>> a = [1,2,3]
    >>> a.pop(1)
    2
    >>> a
    [1, 3]
    
리스트에서 해당 인덱스를 끄집어낸다.

그냥 pop()하면 맨 뒤에 있는 애들이 나온다.

**리스트 확장(extend)**

    >>> a = [1,2,3]
    >>> a.extend([4,5])
    >>> a
    [1, 2, 3, 4, 5]
    >>> b = [6, 7]
    >>> a.extend(b)
    >>> a
    [1, 2, 3, 4, 5, 6, 7]

리스트를 추가할 수 있다. 다른 리스트랑 더할 수도 있다.

### 튜플

**튜플과 리스트의 차이점**

- 리스트는 []로 둘러싸이지만 튜플은 ()으로 둘러싸인다.
- 리스트는 그 값의 생성, 삭제, 수정이 가능하지만, 튜플은 그 값을 바꿀 수 없다. 

튜플은 모습은 다음과 같다.

    >>> t1 = ()
    >>> t2 = (1,)
    >>> t3 = (1, 2, 3)
    >>> t4 = 1, 2, 3
    >>> t5 = ('a', 'b', ('ab', 'cd'))

한개만 가질 때는 뒤에 반점을 찍어야하고 괄호를 생략할 수 있다.

**튜플은 값을 변경하고 싶지 않을 때 사용하는 변수이다.**

하지만 여전히 슬라이싱, 덧셈, 곱셈, 길이구하기는 가능하다.

### 딕셔너리

대응 관계로 되어있는 Hash 형태의 자료형을 파이썬에선 딕셔너리라고 한다.

예를 들어,

    >>> dic = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
    
이 친구는 키값은 각각 name, phone, birth이고 값이 pey, 0119993323, 1118이다.


**딕셔너리 쌍 추가, 삭제하기**

    >>> a = {1: 'a'}
    >>> a[2] = 'b'
    >>> a
    {1: 'a', 2: 'b'}
    >>> a['name'] = 'pey'
    >>> a
    {1: 'a', 2: 'b', 'name': 'pey'}
    >>> a[3] = [1,2,3]
    >>> a
    {1: 'a', 2: 'b', 'name': 'pey', 3: [1, 2, 3]}
    
위와 같이 데이터형에 상관없이 값을 넣어주고 key도 문자열도 가능하다.

    >>> del a[1]
    >>> a
    {2: 'b', 'name': 'pey', 3: [1, 2, 3]}

del함수를 이용해서 삭제할 수 있다.


**딕셔너리에서 Key를 이용해 Value 얻기**

    >>> grade = {'pey': 10, 'julliet': 99}
    >>> grade['pey']
    10
    >>> grade['julliet']
    99


**여기서 중복되는 키값을 설정하게 되면 하나를 제외한 나머지는 다 없어지게 된다.**

**그리고 키값에 list를 넣을 순 없다**

### 딕셔너리 관련 함수들

**key 리스트 만들기**

    >>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
    >>> a.keys()
    dict_keys(['name', 'phone', 'birth'])

이거를 이용하게 되면 반복문을 손쉽게 돌릴 수 있다.

**value 리스트 만들기**

    >>> a.values()
    dict_values(['pey', '0119993323', '1118'])
    
**key, value 쌍으로 얻기(items)**

    >>> a.items()
    dict_items([('name', 'pey'), ('phone', '0119993323'), ('birth', '1118')])

dict_items 객체로 돌려준다.

**딕셔너리 비우기**

    >>> a.clear()
    >>> a
    {}
    
**Key로 Value얻기**

    >>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
    >>> a.get('name')
    'pey'
    >>> a.get('phone')
    '0119993323'
    
그냥 인덱스로 호출하는 것과 달리 얘는 오류를 발생시키는 것이 아니라 None(거짓)을 리턴한다.

    >>> a.get('foo', 'bar')
    'bar'

이렇게 미리 정해준 값이 없다면 디폴트 값을 대신 가져오게 하는 방법도 있다.

해당 Key가 딕셔너리 안에 있는지 조사하기

    >>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
    >>> 'name' in a
    True
    >>> 'email' in a
    False

### 집합

집합과 관련된 것들을 쉽게 처리하기 위해 만들어졌다.

    >>> s2 = set("Hello")
    >>> s2
    {'e', 'H', 'l', 'o'}

뭔가 이상한데 이것은 집합 자료형의 특징을 보여준다.

- 중복을 허용하지 않는다
- 순서가 없다

순서가 없기 때문에 인덱스가 존재하지 않는다. 인덱스를 얻으려면 리스트나 튜플로 변환해야 한다.

    >>> s1 = set([1,2,3])
    >>> l1 = list(s1)
    >>> l1
    [1, 2, 3]
    >>> l1[0]
    1
    >>> t1 = tuple(s1)
    >>> t1
    (1, 2, 3)
    >>> t1[0]
    1


**교집합 구하기**

    >>> s1 & s2
    {4, 5, 6}

혹은
    
    >>> s1.intersection(s2)
    {4, 5, 6}
    
**합집합 구하기**

    >>> s1 | s2
    {1, 2, 3, 4, 5, 6, 7, 8, 9}
    
혹은

    >>> s1.union(s2)
    {1, 2, 3, 4, 5, 6, 7, 8, 9}

**차집합 구하기**

    >>> s1 - s2
    {1, 2, 3}
    >>> s2 - s1
    {8, 9, 7}
    
혹은
    
    >>> s1.difference(s2)
    {1, 2, 3}
    >>> s2.difference(s1)
    {8, 9, 7}
    
**집합에 값 1개 추가하기(add)**

    >>> s1 = set([1, 2, 3])
    >>> s1.add(4)
    >>> s1
    {1, 2, 3, 4}
    
**집합에 값 여러개 추가하기(update)**

    >>> s1 = set([1, 2, 3])
    >>> s1.update([4, 5, 6])
    >>> s1
    {1, 2, 3, 4, 5, 6}

**특정값 제거하기(remove)**

    >>> s1 = set([1, 2, 3])
    >>> s1.remove(2)
    >>> s1
    {1, 3}

### 변수

**리스트복사시**

    >>> a = [1,2,3]
    >>> b = a
    
    >>> a[1] = 4
    >>> a
    [1, 4, 3]
    >>> b
    [1, 4, 3]
    
b는 a의 완전 카피본이 아니라 링크되있는 복사본이다.(같은 주소를 가르키고있다.)


아예 완전 새로운 얘를 만들고 싶다면

**1. [:] 이용**

    >>> a = [1, 2, 3]
    >>> b = a[:]
    >>> a[1] = 4
    >>> a
    [1, 4, 3]
    >>> b
    [1, 2, 3]

**2. copy 모듈 사용**

    >>> from copy import copy
    >>> b = copy(a)

## 제어문

### if문

기본 구조는 다음과 같다.

    if 조건문:
        수행할 문장1
        수행할 문장2
        ...
    else:
        수행할 문장A
        수행할 문장B
        ...

여기서 제일 중요한 것은 **들여쓰기** 이다.

다음 구문은 에러를 발생시킨다.

    money = True
    if money:
        print("택시를")
    print("타고")
        print("가라")


- 4개 스페이스를 쓰는것이 권장된다.
- if 문 뒤에는 콜론(:)이 들어간다는 거 잊지말자.


다양한 조건을 확인할 때는 elif를 사용해라(else if 와 같다.)

if문 내에서 아무것도 안하고 싶으면 pass를 시켜라.

    >>> pocket = ['paper', 'money', 'cellphone']
    >>> if 'money' in pocket:
    ...     pass 
    ... else:
    ...     print("카드를 꺼내라")
    ...


### for문

전형적인 형태는 다음과 같다. C에서 사용하는 포문과는 조금 다르다.

    >>> test_list = ['one', 'two', 'three'] 
    >>> for i in test_list: 
    ...     print(i)
    ... 
    one 
    two 
    three

range라는 함수와 자주 같이 쓰인다. range는 알아서 특정 범위의 객체를 만들어주는 역할을 한다.

iteration 횟수를 세기 위해서 유용하게 쓰입니다.

    #marks3.py
    marks = [90, 25, 67, 45, 80]
    for number in range(len(marks)):
    if marks[number] < 60: 
    continue
    print("%d번 학생 축하합니다. 합격입니다." % (number+1))

**리스트 안에 for문 포함하기**

    >>> a = [1,2,3,4]
    >>> result = [num * 3 for num in a]
    >>> print(result)
    [3, 6, 9, 12]

위와 같이 리스트에 for문이 포함되기도 한다.


## 오늘 배운점

- 파이썬이 쉽다고 들었는데 생각보다 정신이 없다.
- 기능이 너무 많고 좋아보이는 게 있는 반면에 이렇게 많으면 내가 다 알고 효율적으로 쓸 수 있을까 걱정이 된다.
- 내일은 한번 파이썬으로 알고리즘 문제까지 풀어보자 ㅎㅎ

