---
title: (백준 알고리즘 문제풀이) 2887번 행성터널
layout: post
date: '2019-09-27 01:00:00'
author: 줌코딩
tags: codingtest tree union-find
cover: "/assets/instacode.png"
categories: codingtest
---

## 문제

[문제 링크](https://www.acmicpc.net/problem/2887)

## 문제 접근

>* 이 문제는 MST 문제로 크루스칼 알고리즘을 이용하면 쉽게 해결할 수 있어보였다.
>* 하지만 예상치 못한 시간 초과...
>* 이 문제에서 거리를 구하는 방식은 x, y, z 각각의 값을 구하기 때문에 굳이 하나의 거리를 구하기 위해서 하나 내에서 비교를 진행할 필요가 없다.
>* 때문에 x, y, z 각각 어레이를 만들어 놓고 sort한 후에 바로 앞 원소와의 거리 차이를 한곳에 모은다.
>* 이렇게 모은 것을 다시 sort하고 하나씩 꺼내보면서 크루스칼 알고리즘의 과정을 진행하면 된다.

## 코드

#include <cstdio>
#include <queue>
#include <cmath>
#include <algorithm>
#define pii pair<int, int>
#define pip pair<int, pii>
#define x first
#define y second
#define N 100002
using namespace std;
int vs, cnt, n, par[N];
pii X[N], Y[N], Z[N];
int find(int i){
    if(par[i] == i)return i;
    return par[i] = find(par[i]);
}
int main(){
    long long ans = 0;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        X[i].y = Y[i].y = Z[i].y = i + 1;
        scanf("%d %d %d", &X[i].x, &Y[i].x, &Z[i].x);
        par[i] = i;
    }
    sort(X, X+n), sort(Y, Y+n), sort(Z, Z+n);
    vector<pip> v(n*3);
    int j = 0;
    for(int i = 1; i < n; i++){
        v[j++] = pip(abs(X[i].x - X[i-1].x), pii(X[i].y, X[i-1].y));
        v[j++] = pip(abs(Y[i].x - Y[i-1].x), pii(Y[i].y, Y[i-1].y));
        v[j++] = pip(abs(Z[i].x - Z[i-1].x), pii(Z[i].y, Z[i-1].y));
    }
    sort(v.begin(), v.end());
    vs = v.size();
    for(int i = 0; i < vs; i++){
        int px = find(v[i].y.x), py = find(v[i].y.y);
        if(px == py)continue;
        ans += v[i].x, cnt++, par[px] = py;
        if(cnt == n - 1)break;
    }
    printf("%lld", ans);
}

## 느낀점

>* 방법이 틀린게 아니라면 조금 더 효율적으로 발전 시킬 수 있는 방법을 떠올리기 위해 이런저런 생각을 시도해보자!
